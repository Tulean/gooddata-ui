/*
 * Copyright (C) 2007-2017, GoodData(R) Corporation. All rights reserved.
 */
package com.gooddata.cfal.access;

import static com.gooddata.md.Restriction.identifier;
import static java.lang.String.format;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.Is.is;

import com.gooddata.ReportExecuteService;
import com.gooddata.auditevent.AuditEvent;
import com.gooddata.cfal.AbstractAT;
import com.gooddata.export.ExecuteReport;
import com.gooddata.export.ExecuteReportDefinition;
import com.gooddata.md.Attribute;
import com.gooddata.md.report.Report;
import com.gooddata.md.report.ReportDefinition;
import com.gooddata.notification.Channel;
import com.gooddata.notification.EmailConfiguration;
import com.gooddata.notification.MessageTemplate;
import com.gooddata.notification.Subscription;
import com.gooddata.notification.TimerEvent;
import com.gooddata.notification.TriggerCondition;
import com.gooddata.project.Project;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

public class DataAccessAT extends AbstractAT {

    private static final String MESSAGE_TYPE = "DATA_ACCESS";
    private static final String DATA_RESULT = "dataResult";
    private static final String VALID_ELEMENTS = "validElements";
    private static final String ELEMENTS = "elements";

    private Project project;
    private Channel channel;
    private Subscription subscription;

    private final ReportExecuteService reportExecuteService = gd.getReportExecuteService();

    @BeforeClass(groups = MESSAGE_TYPE)
    public void setUp() throws Exception {
        project = projectHelper.getOrCreateProject();

        final Report report = metadataHelper.getOrCreateReport(project);
        final ReportDefinition reportDefinition = metadataHelper.getOrCreateReportDefinition(project);

        metadataHelper.ensureDataLoaded(project);

        final ExecuteReport reportRequest = new ExecuteReport(report);
        final ExecuteReportDefinition reportDefinitionRequest = new ExecuteReportDefinition(reportDefinition);

        reportExecuteService.executeUsingAppExecuteResource(project, reportRequest);
        reportExecuteService.executeUsingAppExecuteResource(project, reportDefinitionRequest);

        reportExecuteService.executeUsingExecuteResource(project, reportRequest);
        reportExecuteService.executeUsingExecuteResource(project, reportDefinitionRequest);

        reportExecuteService.executeUsingXtabExecutorResource(project, reportRequest);
        reportExecuteService.executeUsingXtabExecutorResource(project, reportDefinitionRequest);

        final Attribute attr = gd.getMetadataService().getObj(project, Attribute.class, identifier("attr.star.name"));

        gd.getMetadataService().getAttributeValidElements(attr);

        gd.getMetadataService().getAttributeElements(attr);

        createSubscriptionAndWait(reportDefinition);
    }

    @AfterClass
    public void tearDown() {
        if (subscription != null) {
            gd.getNotificationService().removeSubscription(subscription);
        }
        if (channel != null) {
            gd.getNotificationService().removeChannel(channel);
        }
    }

    @Test(groups = MESSAGE_TYPE)
    public void testDataAccessMessageUserApi() throws Exception {
        doTestUserApi(eventCheck(), MESSAGE_TYPE, getTimes());
    }

    @Test(groups = MESSAGE_TYPE)
    public void testDataAccessMessageAdminApi() throws Exception {
        doTestAdminApi(eventCheck(), MESSAGE_TYPE, getTimes());
    }

    @Test(groups = MESSAGE_TYPE)
    public void testValidElementsAccessMessageUserApi() throws Exception {
        doTestUserApi(validElementsEventCheck(), MESSAGE_TYPE);
    }

    @Test(groups = MESSAGE_TYPE)
    public void testValidElementsAccessMessageAdminApi() throws Exception {
        doTestAdminApi(validElementsEventCheck(), MESSAGE_TYPE);
    }

    @Test(groups = MESSAGE_TYPE)
    public void testElementsAccessMessageUserApi() throws Exception {
        doTestUserApi(elementsEventCheck(), MESSAGE_TYPE);
    }

    @Test(groups = MESSAGE_TYPE)
    public void testElementsAccessMessageAdminApi() throws Exception {
        doTestAdminApi(elementsEventCheck(), MESSAGE_TYPE);
    }

    private int getTimes() {
        return reportExecuteService.getTimesExecuted() + 1; // +1 because 1 dataResult is generated by subscription
    }

    private void createSubscriptionAndWait(final ReportDefinition reportDefinition) throws InterruptedException {
        assertThat(reportDefinition.getGrid().getMetrics(), is(not(emptyList())));

        final String metricUri = reportDefinition.getGrid().getMetrics().get(0).getUri();

        channel = gd.getNotificationService().createChannel(
                getAccount(),
                new Channel(
                        new EmailConfiguration(
                                getAccount().getEmail()
                        ),
                        "cfal channel"
                )
        );

        subscription = gd.getNotificationService().createSubscription(
                project,
                getAccount(),
                new Subscription(
                        singletonList(new TimerEvent("* * * * * *")),
                        singletonList(channel),
                        new TriggerCondition("true"),
                        new MessageTemplate(format("ahoj ${f:executeMetric('%s')}", metricUri)),
                        "cfal subscription"
                )
        );

        logger.info("waiting {} seconds for subscription to execute", props.getNotificationWaitSeconds());
        TimeUnit.SECONDS.sleep(props.getNotificationWaitSeconds()); //give notification worker some time to execute our subscription
    }

    private Predicate<AuditEvent> eventCheck() {
        return e -> e.getUserLogin().equals(getAccount().getLogin())
                && e.getType().equals(MESSAGE_TYPE)
                && e.isSuccess()
                && DATA_RESULT.equals(e.getParams().get("type"))
                && project.getUri().equals(e.getLinks().get("project"));
    }

    private Predicate<AuditEvent> validElementsEventCheck() {
        return e -> e.getUserLogin().equals(getAccount().getLogin())
                && e.getType().equals(MESSAGE_TYPE)
                && e.isSuccess()
                && VALID_ELEMENTS.equals(e.getParams().get("type"))
                && project.getUri().equals(e.getLinks().get("project"));
    }

    private Predicate<AuditEvent> elementsEventCheck() {
        return e -> e.getUserLogin().equals(getAccount().getLogin())
                && e.getType().equals(MESSAGE_TYPE)
                && e.isSuccess()
                && ELEMENTS.equals(e.getParams().get("type"))
                && project.getUri().equals(e.getLinks().get("project"));
    }
}
